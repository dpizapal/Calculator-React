{"ast":null,"code":"import _classCallCheck from \"/workspaces/Calculator-React/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/workspaces/Calculator-React/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/workspaces/Calculator-React/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/workspaces/Calculator-React/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isConstantNode, isOperatorNode, isParenthesisNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty, isSafeMethod } from '../../utils/customs.js';\nimport { getAssociativity, getPrecedence, isAssociativeWith, properties } from '../operators.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nexport var createOperatorNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * Returns true if the expression starts with a constant, under\n   * the current parenthesization:\n   * @param {Node} expression\n   * @param {string} parenthesis\n   * @return {boolean}\n   */\n\n  function startsWithConstant(expr, parenthesis) {\n    var curNode = expr;\n\n    if (parenthesis === 'auto') {\n      while (isParenthesisNode(curNode)) {\n        curNode = curNode.content;\n      }\n    }\n\n    if (isConstantNode(curNode)) return true;\n\n    if (isOperatorNode(curNode)) {\n      return startsWithConstant(curNode.args[0], parenthesis);\n    }\n\n    return false;\n  }\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = getPrecedence(root, parenthesis, implicit);\n    var associativity = getAssociativity(root, parenthesis);\n\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n\n          default:\n            return true;\n        }\n      });\n    }\n\n    var result;\n\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root); // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n\n            if (properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n\n            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          } // otherwise, no parens needed\n\n\n          result = [false];\n        }\n        break;\n\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n\n          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root); // is the root node associative with the left hand side\n\n          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);\n\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n\n          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root); // is the root node associative with the right hand side?\n\n          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);\n\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          } // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n\n          if (latex) {\n            var _rootIdentifier;\n\n            var lhsIdentifier;\n            var rhsIdentifier;\n\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n\n            if (lhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n\n              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n\n            if (rhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n\n              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n\n          result = [lhsParens, rhsParens];\n        }\n        break;\n\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = getPrecedence(arg, parenthesis, implicit, root);\n            var assocWithArg = isAssociativeWith(root, arg, parenthesis);\n            var argAssociativity = getAssociativity(arg, parenthesis);\n\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        break;\n    } // Handles an edge case of parentheses with implicit multiplication\n    // of ConstantNode.\n    // In that case, parenthesize ConstantNodes that follow an unparenthesized\n    // expression, even though they normally wouldn't be printed.\n\n\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis !== 'all' && implicit === 'hide') {\n      for (var i = 1; i < result.length; ++i) {\n        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== 'keep' || !isParenthesisNode(args[i - 1]))) {\n          result[i] = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  var OperatorNode = /*#__PURE__*/function (_Node) {\n    _inherits(OperatorNode, _Node);\n\n    var _super = _createSuper(OperatorNode);\n\n    /**\n     * @constructor OperatorNode\n     * @extends {Node}\n     * An operator with two arguments, like 2+3\n     *\n     * @param {string} op           Operator name, for example '+'\n     * @param {string} fn           Function name, for example 'add'\n     * @param {Node[]} args         Operator arguments\n     * @param {boolean} [implicit]  Is this an implicit multiplication?\n     * @param {boolean} [isPercentage] Is this an percentage Operation?\n     */\n    function OperatorNode(op, fn, args, implicit, isPercentage) {\n      var _this;\n\n      _classCallCheck(this, OperatorNode);\n\n      _this = _super.call(this); // validate input\n\n      if (typeof op !== 'string') {\n        throw new TypeError('string expected for parameter \"op\"');\n      }\n\n      if (typeof fn !== 'string') {\n        throw new TypeError('string expected for parameter \"fn\"');\n      }\n\n      if (!Array.isArray(args) || !args.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n      }\n\n      _this.implicit = implicit === true;\n      _this.isPercentage = isPercentage === true;\n      _this.op = op;\n      _this.fn = fn;\n      _this.args = args || [];\n      return _this;\n    }\n\n    _createClass(OperatorNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isOperatorNode\",\n      get: function get() {\n        return true;\n      }\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        // validate fn\n        if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {\n          if (!math[this.fn]) {\n            throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n          } else {\n            throw new Error('No access to function \"' + this.fn + '\"');\n          }\n        }\n\n        var fn = getSafeProperty(math, this.fn);\n        var evalArgs = map(this.args, function (arg) {\n          return arg._compile(math, argNames);\n        });\n\n        if (evalArgs.length === 1) {\n          var evalArg0 = evalArgs[0];\n          return function evalOperatorNode(scope, args, context) {\n            return fn(evalArg0(scope, args, context));\n          };\n        } else if (evalArgs.length === 2) {\n          var _evalArg = evalArgs[0];\n          var evalArg1 = evalArgs[1];\n          return function evalOperatorNode(scope, args, context) {\n            return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n          };\n        } else {\n          return function evalOperatorNode(scope, args, context) {\n            return fn.apply(null, map(evalArgs, function (evalArg) {\n              return evalArg(scope, args, context);\n            }));\n          };\n        }\n      }\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        for (var i = 0; i < this.args.length; i++) {\n          callback(this.args[i], 'args[' + i + ']', this);\n        }\n      }\n      /**\n       * Create a new OperatorNode whose children are the results of calling\n       * the provided callback function for each child of the original node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {OperatorNode} Returns a transformed copy of the node\n       */\n\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        var args = [];\n\n        for (var i = 0; i < this.args.length; i++) {\n          args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n        }\n\n        return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);\n      }\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {OperatorNode}\n       */\n\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);\n      }\n      /**\n       * Check whether this is an unary OperatorNode:\n       * has exactly one argument, like `-a`.\n       * @return {boolean}\n       *     Returns true when an unary operator node, false otherwise.\n       */\n\n    }, {\n      key: \"isUnary\",\n      value: function isUnary() {\n        return this.args.length === 1;\n      }\n      /**\n       * Check whether this is a binary OperatorNode:\n       * has exactly two arguments, like `a + b`.\n       * @return {boolean}\n       *     Returns true when a binary operator node, false otherwise.\n       */\n\n    }, {\n      key: \"isBinary\",\n      value: function isBinary() {\n        return this.args.length === 2;\n      }\n      /**\n       * Get string representation.\n       * @param {Object} options\n       * @return {string} str\n       */\n\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var implicit = options && options.implicit ? options.implicit : 'hide';\n        var args = this.args;\n        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n        if (args.length === 1) {\n          // unary operators\n          var assoc = getAssociativity(this, parenthesis);\n          var operand = args[0].toString(options);\n\n          if (parens[0]) {\n            operand = '(' + operand + ')';\n          } // for example for \"not\", we want a space between operand and argument\n\n\n          var opIsNamed = /[a-zA-Z]+/.test(this.op);\n\n          if (assoc === 'right') {\n            // prefix operator\n            return this.op + (opIsNamed ? ' ' : '') + operand;\n          } else if (assoc === 'left') {\n            // postfix\n            return operand + (opIsNamed ? ' ' : '') + this.op;\n          } // fall back to postfix\n\n\n          return operand + this.op;\n        } else if (args.length === 2) {\n          var lhs = args[0].toString(options); // left hand side\n\n          var rhs = args[1].toString(options); // right hand side\n\n          if (parens[0]) {\n            // left hand side in parenthesis?\n            lhs = '(' + lhs + ')';\n          }\n\n          if (parens[1]) {\n            // right hand side in parenthesis?\n            rhs = '(' + rhs + ')';\n          }\n\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return lhs + ' ' + rhs;\n          }\n\n          return lhs + ' ' + this.op + ' ' + rhs;\n        } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n          var stringifiedArgs = args.map(function (arg, index) {\n            arg = arg.toString(options);\n\n            if (parens[index]) {\n              // put in parenthesis?\n              arg = '(' + arg + ')';\n            }\n\n            return arg;\n          });\n\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return stringifiedArgs.join(' ');\n          }\n\n          return stringifiedArgs.join(' ' + this.op + ' ');\n        } else {\n          // fallback to formatting as a function call\n          return this.fn + '(' + this.args.join(', ') + ')';\n        }\n      }\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: name,\n          op: this.op,\n          fn: this.fn,\n          args: this.args,\n          implicit: this.implicit,\n          isPercentage: this.isPercentage\n        };\n      }\n      /**\n       * Instantiate an OperatorNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     ```\n       *     {\"mathjs\": \"OperatorNode\",\n       *      \"op\": \"+\", \"fn\": \"add\", \"args\": [...],\n       *      \"implicit\": false,\n       *      \"isPercentage\":false}\n       *     ```\n       *     where mathjs is optional\n       * @returns {OperatorNode}\n       */\n\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\n       * Get HTML representation.\n       * @param {Object} options\n       * @return {string} str\n       */\n      function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var implicit = options && options.implicit ? options.implicit : 'hide';\n        var args = this.args;\n        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n        if (args.length === 1) {\n          // unary operators\n          var assoc = getAssociativity(this, parenthesis);\n          var operand = args[0].toHTML(options);\n\n          if (parens[0]) {\n            operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n\n          if (assoc === 'right') {\n            // prefix operator\n            return '<span class=\"math-operator math-unary-operator ' + 'math-lefthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n          } else {\n            // postfix when assoc === 'left' or undefined\n            return operand + '<span class=\"math-operator math-unary-operator ' + 'math-righthand-unary-operator\">' + escape(this.op) + '</span>';\n          }\n        } else if (args.length === 2) {\n          // binary operatoes\n          var lhs = args[0].toHTML(options); // left hand side\n\n          var rhs = args[1].toHTML(options); // right hand side\n\n          if (parens[0]) {\n            // left hand side in parenthesis?\n            lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n\n          if (parens[1]) {\n            // right hand side in parenthesis?\n            rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>' + rhs;\n          }\n\n          return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>' + rhs;\n        } else {\n          var stringifiedArgs = args.map(function (arg, index) {\n            arg = arg.toHTML(options);\n\n            if (parens[index]) {\n              // put in parenthesis?\n              arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n            }\n\n            return arg;\n          });\n\n          if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n            if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n              return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>');\n            }\n\n            return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>');\n          } else {\n            // fallback to formatting as a function call\n            return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">' + '(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n          }\n        }\n      }\n      /**\n       * Get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       */\n\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var implicit = options && options.implicit ? options.implicit : 'hide';\n        var args = this.args;\n        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n        var op = latexOperators[this.fn];\n        op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n        if (args.length === 1) {\n          // unary operators\n          var assoc = getAssociativity(this, parenthesis);\n          var operand = args[0].toTex(options);\n\n          if (parens[0]) {\n            operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n          }\n\n          if (assoc === 'right') {\n            // prefix operator\n            return op + operand;\n          } else if (assoc === 'left') {\n            // postfix operator\n            return operand + op;\n          } // fall back to postfix\n\n\n          return operand + op;\n        } else if (args.length === 2) {\n          // binary operators\n          var lhs = args[0]; // left hand side\n\n          var lhsTex = lhs.toTex(options);\n\n          if (parens[0]) {\n            lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n          }\n\n          var rhs = args[1]; // right hand side\n\n          var rhsTex = rhs.toTex(options);\n\n          if (parens[1]) {\n            rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n          } // handle some exceptions (due to the way LaTeX works)\n\n\n          var lhsIdentifier;\n\n          if (parenthesis === 'keep') {\n            lhsIdentifier = lhs.getIdentifier();\n          } else {\n            // Ignore ParenthesisNodes if in 'keep' mode\n            lhsIdentifier = lhs.getContent().getIdentifier();\n          }\n\n          switch (this.getIdentifier()) {\n            case 'OperatorNode:divide':\n              // op contains '\\\\frac' at this point\n              return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n\n            case 'OperatorNode:pow':\n              lhsTex = '{' + lhsTex + '}';\n              rhsTex = '{' + rhsTex + '}';\n\n              switch (lhsIdentifier) {\n                case 'ConditionalNode': //\n\n                case 'OperatorNode:divide':\n                  lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n              }\n\n              break;\n\n            case 'OperatorNode:multiply':\n              if (this.implicit && implicit === 'hide') {\n                return lhsTex + '~' + rhsTex;\n              }\n\n          }\n\n          return lhsTex + op + rhsTex;\n        } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n          var texifiedArgs = args.map(function (arg, index) {\n            arg = arg.toTex(options);\n\n            if (parens[index]) {\n              arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n            }\n\n            return arg;\n          });\n\n          if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit && implicit === 'hide') {\n            return texifiedArgs.join('~');\n          }\n\n          return texifiedArgs.join(op);\n        } else {\n          // fall back to formatting as a function call\n          // as this is a fallback, it doesn't use\n          // fancy function names\n          return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n            return arg.toTex(options);\n          }).join(',') + '\\\\right)';\n        }\n      }\n      /**\n       * Get identifier.\n       * @return {string}\n       */\n\n    }, {\n      key: \"getIdentifier\",\n      value: function getIdentifier() {\n        return this.type + ':' + this.fn;\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);\n      }\n    }]);\n\n    return OperatorNode;\n  }(Node);\n\n  _defineProperty(OperatorNode, \"name\", name);\n\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isNode","isConstantNode","isOperatorNode","isParenthesisNode","map","escape","getSafeProperty","isSafeMethod","getAssociativity","getPrecedence","isAssociativeWith","properties","latexOperators","factory","name","dependencies","createOperatorNode","_ref","Node","startsWithConstant","expr","parenthesis","curNode","content","args","calculateNecessaryParentheses","root","implicit","latex","precedence","associativity","length","getIdentifier","arg","getContent","type","result","operandPrecedence","operandIdentifier","rootIdentifier","latexLeftParens","latexParens","lhsParens","lhsPrecedence","assocWithLhs","rhsParens","rhsPrecedence","assocWithRhs","_rootIdentifier","lhsIdentifier","rhsIdentifier","latexRightParens","argPrecedence","assocWithArg","argAssociativity","i","OperatorNode","op","fn","isPercentage","TypeError","Array","isArray","every","math","argNames","Error","evalArgs","_compile","evalArg0","evalOperatorNode","scope","context","_evalArg","evalArg1","apply","evalArg","callback","_ifNode","slice","options","parens","assoc","operand","toString","opIsNamed","test","lhs","rhs","stringifiedArgs","index","join","mathjs","toHTML","toTex","concat","lhsTex","rhsTex","texifiedArgs","json","isClass"],"sources":["/workspaces/Calculator-React/node_modules/mathjs/lib/esm/expression/node/OperatorNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isConstantNode, isOperatorNode, isParenthesisNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty, isSafeMethod } from '../../utils/customs.js';\nimport { getAssociativity, getPrecedence, isAssociativeWith, properties } from '../operators.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nexport var createOperatorNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * Returns true if the expression starts with a constant, under\n   * the current parenthesization:\n   * @param {Node} expression\n   * @param {string} parenthesis\n   * @return {boolean}\n   */\n  function startsWithConstant(expr, parenthesis) {\n    var curNode = expr;\n\n    if (parenthesis === 'auto') {\n      while (isParenthesisNode(curNode)) {\n        curNode = curNode.content;\n      }\n    }\n\n    if (isConstantNode(curNode)) return true;\n\n    if (isOperatorNode(curNode)) {\n      return startsWithConstant(curNode.args[0], parenthesis);\n    }\n\n    return false;\n  }\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = getPrecedence(root, parenthesis, implicit);\n    var associativity = getAssociativity(root, parenthesis);\n\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n\n          default:\n            return true;\n        }\n      });\n    }\n\n    var result;\n\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root); // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n\n            if (properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n\n            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          } // otherwise, no parens needed\n\n\n          result = [false];\n        }\n        break;\n\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n\n          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root); // is the root node associative with the left hand side\n\n          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);\n\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n\n          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root); // is the root node associative with the right hand side?\n\n          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);\n\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          } // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n\n          if (latex) {\n            var _rootIdentifier;\n\n            var lhsIdentifier;\n            var rhsIdentifier;\n\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n\n            if (lhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n\n              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n\n            if (rhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n\n              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n\n          result = [lhsParens, rhsParens];\n        }\n        break;\n\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = getPrecedence(arg, parenthesis, implicit, root);\n            var assocWithArg = isAssociativeWith(root, arg, parenthesis);\n            var argAssociativity = getAssociativity(arg, parenthesis);\n\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        break;\n    } // Handles an edge case of parentheses with implicit multiplication\n    // of ConstantNode.\n    // In that case, parenthesize ConstantNodes that follow an unparenthesized\n    // expression, even though they normally wouldn't be printed.\n\n\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis !== 'all' && implicit === 'hide') {\n      for (var i = 1; i < result.length; ++i) {\n        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== 'keep' || !isParenthesisNode(args[i - 1]))) {\n          result[i] = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  class OperatorNode extends Node {\n    /**\n     * @constructor OperatorNode\n     * @extends {Node}\n     * An operator with two arguments, like 2+3\n     *\n     * @param {string} op           Operator name, for example '+'\n     * @param {string} fn           Function name, for example 'add'\n     * @param {Node[]} args         Operator arguments\n     * @param {boolean} [implicit]  Is this an implicit multiplication?\n     * @param {boolean} [isPercentage] Is this an percentage Operation?\n     */\n    constructor(op, fn, args, implicit, isPercentage) {\n      super(); // validate input\n\n      if (typeof op !== 'string') {\n        throw new TypeError('string expected for parameter \"op\"');\n      }\n\n      if (typeof fn !== 'string') {\n        throw new TypeError('string expected for parameter \"fn\"');\n      }\n\n      if (!Array.isArray(args) || !args.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n      }\n\n      this.implicit = implicit === true;\n      this.isPercentage = isPercentage === true;\n      this.op = op;\n      this.fn = fn;\n      this.args = args || [];\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isOperatorNode() {\n      return true;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      // validate fn\n      if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {\n        if (!math[this.fn]) {\n          throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n        } else {\n          throw new Error('No access to function \"' + this.fn + '\"');\n        }\n      }\n\n      var fn = getSafeProperty(math, this.fn);\n      var evalArgs = map(this.args, function (arg) {\n        return arg._compile(math, argNames);\n      });\n\n      if (evalArgs.length === 1) {\n        var evalArg0 = evalArgs[0];\n        return function evalOperatorNode(scope, args, context) {\n          return fn(evalArg0(scope, args, context));\n        };\n      } else if (evalArgs.length === 2) {\n        var _evalArg = evalArgs[0];\n        var evalArg1 = evalArgs[1];\n        return function evalOperatorNode(scope, args, context) {\n          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n        };\n      } else {\n        return function evalOperatorNode(scope, args, context) {\n          return fn.apply(null, map(evalArgs, function (evalArg) {\n            return evalArg(scope, args, context);\n          }));\n        };\n      }\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      for (var i = 0; i < this.args.length; i++) {\n        callback(this.args[i], 'args[' + i + ']', this);\n      }\n    }\n    /**\n     * Create a new OperatorNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {OperatorNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      var args = [];\n\n      for (var i = 0; i < this.args.length; i++) {\n        args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n      }\n\n      return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {OperatorNode}\n     */\n\n\n    clone() {\n      return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);\n    }\n    /**\n     * Check whether this is an unary OperatorNode:\n     * has exactly one argument, like `-a`.\n     * @return {boolean}\n     *     Returns true when an unary operator node, false otherwise.\n     */\n\n\n    isUnary() {\n      return this.args.length === 1;\n    }\n    /**\n     * Check whether this is a binary OperatorNode:\n     * has exactly two arguments, like `a + b`.\n     * @return {boolean}\n     *     Returns true when a binary operator node, false otherwise.\n     */\n\n\n    isBinary() {\n      return this.args.length === 2;\n    }\n    /**\n     * Get string representation.\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toString(options);\n\n        if (parens[0]) {\n          operand = '(' + operand + ')';\n        } // for example for \"not\", we want a space between operand and argument\n\n\n        var opIsNamed = /[a-zA-Z]+/.test(this.op);\n\n        if (assoc === 'right') {\n          // prefix operator\n          return this.op + (opIsNamed ? ' ' : '') + operand;\n        } else if (assoc === 'left') {\n          // postfix\n          return operand + (opIsNamed ? ' ' : '') + this.op;\n        } // fall back to postfix\n\n\n        return operand + this.op;\n      } else if (args.length === 2) {\n        var lhs = args[0].toString(options); // left hand side\n\n        var rhs = args[1].toString(options); // right hand side\n\n        if (parens[0]) {\n          // left hand side in parenthesis?\n          lhs = '(' + lhs + ')';\n        }\n\n        if (parens[1]) {\n          // right hand side in parenthesis?\n          rhs = '(' + rhs + ')';\n        }\n\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return lhs + ' ' + rhs;\n        }\n\n        return lhs + ' ' + this.op + ' ' + rhs;\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        var stringifiedArgs = args.map(function (arg, index) {\n          arg = arg.toString(options);\n\n          if (parens[index]) {\n            // put in parenthesis?\n            arg = '(' + arg + ')';\n          }\n\n          return arg;\n        });\n\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join(' ');\n        }\n\n        return stringifiedArgs.join(' ' + this.op + ' ');\n      } else {\n        // fallback to formatting as a function call\n        return this.fn + '(' + this.args.join(', ') + ')';\n      }\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        op: this.op,\n        fn: this.fn,\n        args: this.args,\n        implicit: this.implicit,\n        isPercentage: this.isPercentage\n      };\n    }\n    /**\n     * Instantiate an OperatorNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     ```\n     *     {\"mathjs\": \"OperatorNode\",\n     *      \"op\": \"+\", \"fn\": \"add\", \"args\": [...],\n     *      \"implicit\": false,\n     *      \"isPercentage\":false}\n     *     ```\n     *     where mathjs is optional\n     * @returns {OperatorNode}\n     */\n\n\n    static fromJSON(json) {\n      return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);\n    }\n    /**\n     * Get HTML representation.\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toHTML(options);\n\n        if (parens[0]) {\n          operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        if (assoc === 'right') {\n          // prefix operator\n          return '<span class=\"math-operator math-unary-operator ' + 'math-lefthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n        } else {\n          // postfix when assoc === 'left' or undefined\n          return operand + '<span class=\"math-operator math-unary-operator ' + 'math-righthand-unary-operator\">' + escape(this.op) + '</span>';\n        }\n      } else if (args.length === 2) {\n        // binary operatoes\n        var lhs = args[0].toHTML(options); // left hand side\n\n        var rhs = args[1].toHTML(options); // right hand side\n\n        if (parens[0]) {\n          // left hand side in parenthesis?\n          lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        if (parens[1]) {\n          // right hand side in parenthesis?\n          rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>' + rhs;\n        }\n\n        return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>' + rhs;\n      } else {\n        var stringifiedArgs = args.map(function (arg, index) {\n          arg = arg.toHTML(options);\n\n          if (parens[index]) {\n            // put in parenthesis?\n            arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n\n          return arg;\n        });\n\n        if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>');\n          }\n\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>');\n        } else {\n          // fallback to formatting as a function call\n          return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">' + '(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n        }\n      }\n    }\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n      var op = latexOperators[this.fn];\n      op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toTex(options);\n\n        if (parens[0]) {\n          operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n        }\n\n        if (assoc === 'right') {\n          // prefix operator\n          return op + operand;\n        } else if (assoc === 'left') {\n          // postfix operator\n          return operand + op;\n        } // fall back to postfix\n\n\n        return operand + op;\n      } else if (args.length === 2) {\n        // binary operators\n        var lhs = args[0]; // left hand side\n\n        var lhsTex = lhs.toTex(options);\n\n        if (parens[0]) {\n          lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n        }\n\n        var rhs = args[1]; // right hand side\n\n        var rhsTex = rhs.toTex(options);\n\n        if (parens[1]) {\n          rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n        } // handle some exceptions (due to the way LaTeX works)\n\n\n        var lhsIdentifier;\n\n        if (parenthesis === 'keep') {\n          lhsIdentifier = lhs.getIdentifier();\n        } else {\n          // Ignore ParenthesisNodes if in 'keep' mode\n          lhsIdentifier = lhs.getContent().getIdentifier();\n        }\n\n        switch (this.getIdentifier()) {\n          case 'OperatorNode:divide':\n            // op contains '\\\\frac' at this point\n            return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n\n          case 'OperatorNode:pow':\n            lhsTex = '{' + lhsTex + '}';\n            rhsTex = '{' + rhsTex + '}';\n\n            switch (lhsIdentifier) {\n              case 'ConditionalNode': //\n\n              case 'OperatorNode:divide':\n                lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n            }\n\n            break;\n\n          case 'OperatorNode:multiply':\n            if (this.implicit && implicit === 'hide') {\n              return lhsTex + '~' + rhsTex;\n            }\n\n        }\n\n        return lhsTex + op + rhsTex;\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        var texifiedArgs = args.map(function (arg, index) {\n          arg = arg.toTex(options);\n\n          if (parens[index]) {\n            arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n          }\n\n          return arg;\n        });\n\n        if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit && implicit === 'hide') {\n          return texifiedArgs.join('~');\n        }\n\n        return texifiedArgs.join(op);\n      } else {\n        // fall back to formatting as a function call\n        // as this is a fallback, it doesn't use\n        // fancy function names\n        return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n          return arg.toTex(options);\n        }).join(',') + '\\\\right)';\n      }\n    }\n    /**\n     * Get identifier.\n     * @return {string}\n     */\n\n\n    getIdentifier() {\n      return this.type + ':' + this.fn;\n    }\n\n  }\n\n  _defineProperty(OperatorNode, \"name\", name);\n\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}