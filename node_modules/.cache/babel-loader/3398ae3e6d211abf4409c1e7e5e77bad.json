{"ast":null,"code":"import { factory } from '../../../utils/factory.js';\nimport { extend } from '../../../utils/object.js';\nimport { createMatAlgo13xDD } from './matAlgo13xDD.js';\nimport { createMatAlgo14xDs } from './matAlgo14xDs.js';\nvar name = 'matrixAlgorithmSuite';\nvar dependencies = ['typed', 'matrix'];\nexport var createMatrixAlgorithmSuite = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix;\n  var matAlgo13xDD = createMatAlgo13xDD({\n    typed: typed\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed: typed\n  });\n  /**\n   * Return a signatures object with the usual boilerplate of\n   * matrix algorithms, based on a plain options object with the\n   * following properties:\n   *   elop: function -- the elementwise operation to use, defaults to self\n   *   SS: function -- the algorithm to apply for two sparse matrices\n   *   DS: function -- the algorithm to apply for a dense and a sparse matrix\n   *   SD: function -- algo for a sparse and a dense; defaults to SD flipped\n   *   Ss: function -- the algorithm to apply for a sparse matrix and scalar\n   *   sS: function -- algo for scalar and sparse; defaults to Ss flipped\n   *   scalar: string -- typed-function type for scalars, defaults to 'any'\n   *\n   * If Ss is not specified, no matrix-scalar signatures are generated.\n   *\n   * @param {object} options\n   * @return {Object<string, function>} signatures\n   */\n\n  return function matrixAlgorithmSuite(options) {\n    var elop = options.elop;\n    var SD = options.SD || options.DS;\n    var matrixSignatures;\n\n    if (elop) {\n      // First the dense ones\n      matrixSignatures = {\n        'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {\n          return matAlgo13xDD(x, y, elop);\n        },\n        'Array, Array': function ArrayArray(x, y) {\n          return matAlgo13xDD(matrix(x), matrix(y), elop).valueOf();\n        },\n        'Array, DenseMatrix': function ArrayDenseMatrix(x, y) {\n          return matAlgo13xDD(matrix(x), y, elop);\n        },\n        'DenseMatrix, Array': function DenseMatrixArray(x, y) {\n          return matAlgo13xDD(x, matrix(y), elop);\n        }\n      }; // Now incorporate sparse matrices\n\n      if (options.SS) {\n        matrixSignatures['SparseMatrix, SparseMatrix'] = function (x, y) {\n          return options.SS(x, y, elop, false);\n        };\n      }\n\n      if (options.DS) {\n        matrixSignatures['DenseMatrix, SparseMatrix'] = function (x, y) {\n          return options.DS(x, y, elop, false);\n        };\n\n        matrixSignatures['Array, SparseMatrix'] = function (x, y) {\n          return options.DS(matrix(x), y, elop, false);\n        };\n      }\n\n      if (SD) {\n        matrixSignatures['SparseMatrix, DenseMatrix'] = function (x, y) {\n          return SD(y, x, elop, true);\n        };\n\n        matrixSignatures['SparseMatrix, Array'] = function (x, y) {\n          return SD(matrix(y), x, elop, true);\n        };\n      }\n    } else {\n      // No elop, use this\n      // First the dense ones\n      matrixSignatures = {\n        'DenseMatrix, DenseMatrix': typed.referToSelf(function (self) {\n          return function (x, y) {\n            return matAlgo13xDD(x, y, self);\n          };\n        }),\n        'Array, Array': typed.referToSelf(function (self) {\n          return function (x, y) {\n            return matAlgo13xDD(matrix(x), matrix(y), self).valueOf();\n          };\n        }),\n        'Array, DenseMatrix': typed.referToSelf(function (self) {\n          return function (x, y) {\n            return matAlgo13xDD(matrix(x), y, self);\n          };\n        }),\n        'DenseMatrix, Array': typed.referToSelf(function (self) {\n          return function (x, y) {\n            return matAlgo13xDD(x, matrix(y), self);\n          };\n        })\n      }; // Now incorporate sparse matrices\n\n      if (options.SS) {\n        matrixSignatures['SparseMatrix, SparseMatrix'] = typed.referToSelf(function (self) {\n          return function (x, y) {\n            return options.SS(x, y, self, false);\n          };\n        });\n      }\n\n      if (options.DS) {\n        matrixSignatures['DenseMatrix, SparseMatrix'] = typed.referToSelf(function (self) {\n          return function (x, y) {\n            return options.DS(x, y, self, false);\n          };\n        });\n        matrixSignatures['Array, SparseMatrix'] = typed.referToSelf(function (self) {\n          return function (x, y) {\n            return options.DS(matrix(x), y, self, false);\n          };\n        });\n      }\n\n      if (SD) {\n        matrixSignatures['SparseMatrix, DenseMatrix'] = typed.referToSelf(function (self) {\n          return function (x, y) {\n            return SD(y, x, self, true);\n          };\n        });\n        matrixSignatures['SparseMatrix, Array'] = typed.referToSelf(function (self) {\n          return function (x, y) {\n            return SD(matrix(y), x, self, true);\n          };\n        });\n      }\n    } // Now add the scalars\n\n\n    var scalar = options.scalar || 'any';\n    var Ds = options.Ds || options.Ss;\n\n    if (Ds) {\n      if (elop) {\n        matrixSignatures['DenseMatrix,' + scalar] = function (x, y) {\n          return matAlgo14xDs(x, y, elop, false);\n        };\n\n        matrixSignatures[scalar + ', DenseMatrix'] = function (x, y) {\n          return matAlgo14xDs(y, x, elop, true);\n        };\n\n        matrixSignatures['Array,' + scalar] = function (x, y) {\n          return matAlgo14xDs(matrix(x), y, elop, false).valueOf();\n        };\n\n        matrixSignatures[scalar + ', Array'] = function (x, y) {\n          return matAlgo14xDs(matrix(y), x, elop, true).valueOf();\n        };\n      } else {\n        matrixSignatures['DenseMatrix,' + scalar] = typed.referToSelf(function (self) {\n          return function (x, y) {\n            return matAlgo14xDs(x, y, self, false);\n          };\n        });\n        matrixSignatures[scalar + ', DenseMatrix'] = typed.referToSelf(function (self) {\n          return function (x, y) {\n            return matAlgo14xDs(y, x, self, true);\n          };\n        });\n        matrixSignatures['Array,' + scalar] = typed.referToSelf(function (self) {\n          return function (x, y) {\n            return matAlgo14xDs(matrix(x), y, self, false).valueOf();\n          };\n        });\n        matrixSignatures[scalar + ', Array'] = typed.referToSelf(function (self) {\n          return function (x, y) {\n            return matAlgo14xDs(matrix(y), x, self, true).valueOf();\n          };\n        });\n      }\n    }\n\n    var sS = options.sS !== undefined ? options.sS : options.Ss;\n\n    if (elop) {\n      if (options.Ss) {\n        matrixSignatures['SparseMatrix,' + scalar] = function (x, y) {\n          return options.Ss(x, y, elop, false);\n        };\n      }\n\n      if (sS) {\n        matrixSignatures[scalar + ', SparseMatrix'] = function (x, y) {\n          return sS(y, x, elop, true);\n        };\n      }\n    } else {\n      if (options.Ss) {\n        matrixSignatures['SparseMatrix,' + scalar] = typed.referToSelf(function (self) {\n          return function (x, y) {\n            return options.Ss(x, y, self, false);\n          };\n        });\n      }\n\n      if (sS) {\n        matrixSignatures[scalar + ', SparseMatrix'] = typed.referToSelf(function (self) {\n          return function (x, y) {\n            return sS(y, x, self, true);\n          };\n        });\n      }\n    } // Also pull in the scalar signatures if the operator is a typed function\n\n\n    if (elop && elop.signatures) {\n      extend(matrixSignatures, elop.signatures);\n    }\n\n    return matrixSignatures;\n  };\n});","map":{"version":3,"names":["factory","extend","createMatAlgo13xDD","createMatAlgo14xDs","name","dependencies","createMatrixAlgorithmSuite","_ref","typed","matrix","matAlgo13xDD","matAlgo14xDs","matrixAlgorithmSuite","options","elop","SD","DS","matrixSignatures","x","y","valueOf","SS","referToSelf","self","scalar","Ds","Ss","sS","undefined","signatures"],"sources":["/workspaces/Calculator-React/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js"],"sourcesContent":["import { factory } from '../../../utils/factory.js';\nimport { extend } from '../../../utils/object.js';\nimport { createMatAlgo13xDD } from './matAlgo13xDD.js';\nimport { createMatAlgo14xDs } from './matAlgo14xDs.js';\nvar name = 'matrixAlgorithmSuite';\nvar dependencies = ['typed', 'matrix'];\nexport var createMatrixAlgorithmSuite = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix\n  } = _ref;\n  var matAlgo13xDD = createMatAlgo13xDD({\n    typed\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed\n  });\n  /**\n   * Return a signatures object with the usual boilerplate of\n   * matrix algorithms, based on a plain options object with the\n   * following properties:\n   *   elop: function -- the elementwise operation to use, defaults to self\n   *   SS: function -- the algorithm to apply for two sparse matrices\n   *   DS: function -- the algorithm to apply for a dense and a sparse matrix\n   *   SD: function -- algo for a sparse and a dense; defaults to SD flipped\n   *   Ss: function -- the algorithm to apply for a sparse matrix and scalar\n   *   sS: function -- algo for scalar and sparse; defaults to Ss flipped\n   *   scalar: string -- typed-function type for scalars, defaults to 'any'\n   *\n   * If Ss is not specified, no matrix-scalar signatures are generated.\n   *\n   * @param {object} options\n   * @return {Object<string, function>} signatures\n   */\n\n  return function matrixAlgorithmSuite(options) {\n    var elop = options.elop;\n    var SD = options.SD || options.DS;\n    var matrixSignatures;\n\n    if (elop) {\n      // First the dense ones\n      matrixSignatures = {\n        'DenseMatrix, DenseMatrix': (x, y) => matAlgo13xDD(x, y, elop),\n        'Array, Array': (x, y) => matAlgo13xDD(matrix(x), matrix(y), elop).valueOf(),\n        'Array, DenseMatrix': (x, y) => matAlgo13xDD(matrix(x), y, elop),\n        'DenseMatrix, Array': (x, y) => matAlgo13xDD(x, matrix(y), elop)\n      }; // Now incorporate sparse matrices\n\n      if (options.SS) {\n        matrixSignatures['SparseMatrix, SparseMatrix'] = (x, y) => options.SS(x, y, elop, false);\n      }\n\n      if (options.DS) {\n        matrixSignatures['DenseMatrix, SparseMatrix'] = (x, y) => options.DS(x, y, elop, false);\n\n        matrixSignatures['Array, SparseMatrix'] = (x, y) => options.DS(matrix(x), y, elop, false);\n      }\n\n      if (SD) {\n        matrixSignatures['SparseMatrix, DenseMatrix'] = (x, y) => SD(y, x, elop, true);\n\n        matrixSignatures['SparseMatrix, Array'] = (x, y) => SD(matrix(y), x, elop, true);\n      }\n    } else {\n      // No elop, use this\n      // First the dense ones\n      matrixSignatures = {\n        'DenseMatrix, DenseMatrix': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(x, y, self);\n        }),\n        'Array, Array': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(matrix(x), matrix(y), self).valueOf();\n        }),\n        'Array, DenseMatrix': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(matrix(x), y, self);\n        }),\n        'DenseMatrix, Array': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(x, matrix(y), self);\n        })\n      }; // Now incorporate sparse matrices\n\n      if (options.SS) {\n        matrixSignatures['SparseMatrix, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return options.SS(x, y, self, false);\n        });\n      }\n\n      if (options.DS) {\n        matrixSignatures['DenseMatrix, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return options.DS(x, y, self, false);\n        });\n        matrixSignatures['Array, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return options.DS(matrix(x), y, self, false);\n        });\n      }\n\n      if (SD) {\n        matrixSignatures['SparseMatrix, DenseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return SD(y, x, self, true);\n        });\n        matrixSignatures['SparseMatrix, Array'] = typed.referToSelf(self => (x, y) => {\n          return SD(matrix(y), x, self, true);\n        });\n      }\n    } // Now add the scalars\n\n\n    var scalar = options.scalar || 'any';\n    var Ds = options.Ds || options.Ss;\n\n    if (Ds) {\n      if (elop) {\n        matrixSignatures['DenseMatrix,' + scalar] = (x, y) => matAlgo14xDs(x, y, elop, false);\n\n        matrixSignatures[scalar + ', DenseMatrix'] = (x, y) => matAlgo14xDs(y, x, elop, true);\n\n        matrixSignatures['Array,' + scalar] = (x, y) => matAlgo14xDs(matrix(x), y, elop, false).valueOf();\n\n        matrixSignatures[scalar + ', Array'] = (x, y) => matAlgo14xDs(matrix(y), x, elop, true).valueOf();\n      } else {\n        matrixSignatures['DenseMatrix,' + scalar] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(x, y, self, false);\n        });\n        matrixSignatures[scalar + ', DenseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(y, x, self, true);\n        });\n        matrixSignatures['Array,' + scalar] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(matrix(x), y, self, false).valueOf();\n        });\n        matrixSignatures[scalar + ', Array'] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(matrix(y), x, self, true).valueOf();\n        });\n      }\n    }\n\n    var sS = options.sS !== undefined ? options.sS : options.Ss;\n\n    if (elop) {\n      if (options.Ss) {\n        matrixSignatures['SparseMatrix,' + scalar] = (x, y) => options.Ss(x, y, elop, false);\n      }\n\n      if (sS) {\n        matrixSignatures[scalar + ', SparseMatrix'] = (x, y) => sS(y, x, elop, true);\n      }\n    } else {\n      if (options.Ss) {\n        matrixSignatures['SparseMatrix,' + scalar] = typed.referToSelf(self => (x, y) => {\n          return options.Ss(x, y, self, false);\n        });\n      }\n\n      if (sS) {\n        matrixSignatures[scalar + ', SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return sS(y, x, self, true);\n        });\n      }\n    } // Also pull in the scalar signatures if the operator is a typed function\n\n\n    if (elop && elop.signatures) {\n      extend(matrixSignatures, elop.signatures);\n    }\n\n    return matrixSignatures;\n  };\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}