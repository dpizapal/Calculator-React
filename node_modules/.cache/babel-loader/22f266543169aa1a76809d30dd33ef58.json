{"ast":null,"code":"import _classCallCheck from \"/workspaces/Calculator-React/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/workspaces/Calculator-React/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/workspaces/Calculator-React/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/workspaces/Calculator-React/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @param {string} implicit\n   * @return {Object} parentheses\n   * @private\n   */\n\n  function calculateNecessaryParentheses(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n\n  var RangeNode = /*#__PURE__*/function (_Node) {\n    _inherits(RangeNode, _Node);\n\n    var _super = _createSuper(RangeNode);\n\n    /**\n     * @constructor RangeNode\n     * @extends {Node}\n     * create a range\n     * @param {Node} start  included lower-bound\n     * @param {Node} end    included upper-bound\n     * @param {Node} [step] optional step\n     */\n    function RangeNode(start, end, step) {\n      var _this;\n\n      _classCallCheck(this, RangeNode);\n\n      _this = _super.call(this); // validate inputs\n\n      if (!isNode(start)) throw new TypeError('Node expected');\n      if (!isNode(end)) throw new TypeError('Node expected');\n      if (step && !isNode(step)) throw new TypeError('Node expected');\n      if (arguments.length > 3) throw new Error('Too many arguments');\n      _this.start = start; // included lower-bound\n\n      _this.end = end; // included upper-bound\n\n      _this.step = step || null; // optional step\n\n      return _this;\n    }\n\n    _createClass(RangeNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isRangeNode\",\n      get: function get() {\n        return true;\n      }\n      /**\n       * Check whether the RangeNode needs the `end` symbol to be defined.\n       * This end is the size of the Matrix in current dimension.\n       * @return {boolean}\n       */\n\n    }, {\n      key: \"needsEnd\",\n      value: function needsEnd() {\n        // find all `end` symbols in this RangeNode\n        var endSymbols = this.filter(function (node) {\n          return isSymbolNode(node) && node.name === 'end';\n        });\n        return endSymbols.length > 0;\n      }\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        var range = math.range;\n\n        var evalStart = this.start._compile(math, argNames);\n\n        var evalEnd = this.end._compile(math, argNames);\n\n        if (this.step) {\n          var evalStep = this.step._compile(math, argNames);\n\n          return function evalRangeNode(scope, args, context) {\n            return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n          };\n        } else {\n          return function evalRangeNode(scope, args, context) {\n            return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n          };\n        }\n      }\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        callback(this.start, 'start', this);\n        callback(this.end, 'end', this);\n\n        if (this.step) {\n          callback(this.step, 'step', this);\n        }\n      }\n      /**\n       * Create a new RangeNode whose children are the results of calling\n       * the provided callback function for each child of the original node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {RangeNode} Returns a transformed copy of the node\n       */\n\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n      }\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {RangeNode}\n       */\n\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new RangeNode(this.start, this.end, this.step && this.step);\n      }\n      /**\n       * Get string representation\n       * @param {Object} options\n       * @return {string} str\n       */\n\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit); // format string as start:step:stop\n\n        var str;\n        var start = this.start.toString(options);\n\n        if (parens.start) {\n          start = '(' + start + ')';\n        }\n\n        str = start;\n\n        if (this.step) {\n          var step = this.step.toString(options);\n\n          if (parens.step) {\n            step = '(' + step + ')';\n          }\n\n          str += ':' + step;\n        }\n\n        var end = this.end.toString(options);\n\n        if (parens.end) {\n          end = '(' + end + ')';\n        }\n\n        str += ':' + end;\n        return str;\n      }\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: name,\n          start: this.start,\n          end: this.end,\n          step: this.step\n        };\n      }\n      /**\n       * Instantiate an RangeNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n       *     where mathjs is optional\n       * @returns {RangeNode}\n       */\n\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\n       * Get HTML representation\n       * @param {Object} options\n       * @return {string} str\n       */\n      function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit); // format string as start:step:stop\n\n        var str;\n        var start = this.start.toHTML(options);\n\n        if (parens.start) {\n          start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        str = start;\n\n        if (this.step) {\n          var step = this.step.toHTML(options);\n\n          if (parens.step) {\n            step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n\n          str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n        }\n\n        var end = this.end.toHTML(options);\n\n        if (parens.end) {\n          end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n        return str;\n      }\n      /**\n       * Get LaTeX representation\n       * @params {Object} options\n       * @return {string} str\n       */\n\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n        var str = this.start.toTex(options);\n\n        if (parens.start) {\n          str = \"\\\\left(\".concat(str, \"\\\\right)\");\n        }\n\n        if (this.step) {\n          var step = this.step.toTex(options);\n\n          if (parens.step) {\n            step = \"\\\\left(\".concat(step, \"\\\\right)\");\n          }\n\n          str += ':' + step;\n        }\n\n        var end = this.end.toTex(options);\n\n        if (parens.end) {\n          end = \"\\\\left(\".concat(end, \"\\\\right)\");\n        }\n\n        str += ':' + end;\n        return str;\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new RangeNode(json.start, json.end, json.step);\n      }\n    }]);\n\n    return RangeNode;\n  }(Node);\n\n  _defineProperty(RangeNode, \"name\", name);\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isNode","isSymbolNode","factory","getPrecedence","name","dependencies","createRangeNode","_ref","Node","calculateNecessaryParentheses","node","parenthesis","implicit","precedence","parens","startPrecedence","start","step","stepPrecedence","endPrecedence","end","RangeNode","TypeError","arguments","length","Error","endSymbols","filter","math","argNames","range","evalStart","_compile","evalEnd","evalStep","evalRangeNode","scope","args","context","callback","_ifNode","options","str","toString","mathjs","toHTML","toTex","concat","json","isClass"],"sources":["/workspaces/Calculator-React/node_modules/mathjs/lib/esm/expression/node/RangeNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @param {string} implicit\n   * @return {Object} parentheses\n   * @private\n   */\n  function calculateNecessaryParentheses(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n\n  class RangeNode extends Node {\n    /**\n     * @constructor RangeNode\n     * @extends {Node}\n     * create a range\n     * @param {Node} start  included lower-bound\n     * @param {Node} end    included upper-bound\n     * @param {Node} [step] optional step\n     */\n    constructor(start, end, step) {\n      super(); // validate inputs\n\n      if (!isNode(start)) throw new TypeError('Node expected');\n      if (!isNode(end)) throw new TypeError('Node expected');\n      if (step && !isNode(step)) throw new TypeError('Node expected');\n      if (arguments.length > 3) throw new Error('Too many arguments');\n      this.start = start; // included lower-bound\n\n      this.end = end; // included upper-bound\n\n      this.step = step || null; // optional step\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isRangeNode() {\n      return true;\n    }\n    /**\n     * Check whether the RangeNode needs the `end` symbol to be defined.\n     * This end is the size of the Matrix in current dimension.\n     * @return {boolean}\n     */\n\n\n    needsEnd() {\n      // find all `end` symbols in this RangeNode\n      var endSymbols = this.filter(function (node) {\n        return isSymbolNode(node) && node.name === 'end';\n      });\n      return endSymbols.length > 0;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      var range = math.range;\n\n      var evalStart = this.start._compile(math, argNames);\n\n      var evalEnd = this.end._compile(math, argNames);\n\n      if (this.step) {\n        var evalStep = this.step._compile(math, argNames);\n\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n        };\n      } else {\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n        };\n      }\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      callback(this.start, 'start', this);\n      callback(this.end, 'end', this);\n\n      if (this.step) {\n        callback(this.step, 'step', this);\n      }\n    }\n    /**\n     * Create a new RangeNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {RangeNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {RangeNode}\n     */\n\n\n    clone() {\n      return new RangeNode(this.start, this.end, this.step && this.step);\n    }\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit); // format string as start:step:stop\n\n      var str;\n      var start = this.start.toString(options);\n\n      if (parens.start) {\n        start = '(' + start + ')';\n      }\n\n      str = start;\n\n      if (this.step) {\n        var step = this.step.toString(options);\n\n        if (parens.step) {\n          step = '(' + step + ')';\n        }\n\n        str += ':' + step;\n      }\n\n      var end = this.end.toString(options);\n\n      if (parens.end) {\n        end = '(' + end + ')';\n      }\n\n      str += ':' + end;\n      return str;\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        start: this.start,\n        end: this.end,\n        step: this.step\n      };\n    }\n    /**\n     * Instantiate an RangeNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n     *     where mathjs is optional\n     * @returns {RangeNode}\n     */\n\n\n    static fromJSON(json) {\n      return new RangeNode(json.start, json.end, json.step);\n    }\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit); // format string as start:step:stop\n\n      var str;\n      var start = this.start.toHTML(options);\n\n      if (parens.start) {\n        start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str = start;\n\n      if (this.step) {\n        var step = this.step.toHTML(options);\n\n        if (parens.step) {\n          step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n      }\n\n      var end = this.end.toHTML(options);\n\n      if (parens.end) {\n        end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n      return str;\n    }\n    /**\n     * Get LaTeX representation\n     * @params {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n      var str = this.start.toTex(options);\n\n      if (parens.start) {\n        str = \"\\\\left(\".concat(str, \"\\\\right)\");\n      }\n\n      if (this.step) {\n        var step = this.step.toTex(options);\n\n        if (parens.step) {\n          step = \"\\\\left(\".concat(step, \"\\\\right)\");\n        }\n\n        str += ':' + step;\n      }\n\n      var end = this.end.toTex(options);\n\n      if (parens.end) {\n        end = \"\\\\left(\".concat(end, \"\\\\right)\");\n      }\n\n      str += ':' + end;\n      return str;\n    }\n\n  }\n\n  _defineProperty(RangeNode, \"name\", name);\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}