{"ast":null,"code":"import _classCallCheck from \"/workspaces/Calculator-React/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/workspaces/Calculator-React/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/workspaces/Calculator-React/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/workspaces/Calculator-React/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { escape } from '../../utils/string.js';\nimport { forEach, join } from '../../utils/array.js';\nimport { toSymbol } from '../../utils/latex.js';\nimport { getPrecedence } from '../operators.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      Node = _ref.Node;\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @param {string} implicit\n   * @private\n   */\n\n  function needParenthesis(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n\n  var FunctionAssignmentNode = /*#__PURE__*/function (_Node) {\n    _inherits(FunctionAssignmentNode, _Node);\n\n    var _super = _createSuper(FunctionAssignmentNode);\n\n    /**\n     * @constructor FunctionAssignmentNode\n     * @extends {Node}\n     * Function assignment\n     *\n     * @param {string} name           Function name\n     * @param {string[] | Array.<{name: string, type: string}>} params\n     *                                Array with function parameter names, or an\n     *                                array with objects containing the name\n     *                                and type of the parameter\n     * @param {Node} expr             The function expression\n     */\n    function FunctionAssignmentNode(name, params, expr) {\n      var _this;\n\n      _classCallCheck(this, FunctionAssignmentNode);\n\n      _this = _super.call(this); // validate input\n\n      if (typeof name !== 'string') {\n        throw new TypeError('String expected for parameter \"name\"');\n      }\n\n      if (!Array.isArray(params)) {\n        throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n      }\n\n      if (!isNode(expr)) {\n        throw new TypeError('Node expected for parameter \"expr\"');\n      }\n\n      if (keywords.has(name)) {\n        throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n      }\n\n      _this.name = name;\n      _this.params = params.map(function (param) {\n        return param && param.name || param;\n      });\n      _this.types = params.map(function (param) {\n        return param && param.type || 'any';\n      });\n      _this.expr = expr;\n      return _this;\n    }\n\n    _createClass(FunctionAssignmentNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isFunctionAssignmentNode\",\n      get: function get() {\n        return true;\n      }\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        var childArgNames = Object.create(argNames);\n        forEach(this.params, function (param) {\n          childArgNames[param] = true;\n        }); // compile the function expression with the child args\n\n        var evalExpr = this.expr._compile(math, childArgNames);\n\n        var name = this.name;\n        var params = this.params;\n        var signature = join(this.types, ',');\n        var syntax = name + '(' + join(this.params, ', ') + ')';\n        return function evalFunctionAssignmentNode(scope, args, context) {\n          var signatures = {};\n\n          signatures[signature] = function () {\n            var childArgs = Object.create(args);\n\n            for (var i = 0; i < params.length; i++) {\n              childArgs[params[i]] = arguments[i];\n            }\n\n            return evalExpr(scope, childArgs, context);\n          };\n\n          var fn = typed(name, signatures);\n          fn.syntax = syntax;\n          scope.set(name, fn);\n          return fn;\n        };\n      }\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        callback(this.expr, 'expr', this);\n      }\n      /**\n       * Create a new FunctionAssignmentNode whose children are the results of\n       * calling the provided callback function for each child of the original\n       * node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n       */\n\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        var expr = this._ifNode(callback(this.expr, 'expr', this));\n\n        return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n      }\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {FunctionAssignmentNode}\n       */\n\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n      }\n      /**\n       * get string representation\n       * @param {Object} options\n       * @return {string} str\n       */\n\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var expr = this.expr.toString(options);\n\n        if (needParenthesis(this, parenthesis, options && options.implicit)) {\n          expr = '(' + expr + ')';\n        }\n\n        return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n      }\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        var types = this.types;\n        return {\n          mathjs: name,\n          name: this.name,\n          params: this.params.map(function (param, index) {\n            return {\n              name: param,\n              type: types[index]\n            };\n          }),\n          expr: this.expr\n        };\n      }\n      /**\n       * Instantiate an FunctionAssignmentNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     ```\n       *     {\"mathjs\": \"FunctionAssignmentNode\",\n       *      name: ..., params: ..., expr: ...}\n       *     ```\n       *     where mathjs is optional\n       * @returns {FunctionAssignmentNode}\n       */\n\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\n       * get HTML representation\n       * @param {Object} options\n       * @return {string} str\n       */\n      function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var params = [];\n\n        for (var i = 0; i < this.params.length; i++) {\n          params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n        }\n\n        var expr = this.expr.toHTML(options);\n\n        if (needParenthesis(this, parenthesis, options && options.implicit)) {\n          expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n      }\n      /**\n       * get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       */\n\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var expr = this.expr.toTex(options);\n\n        if (needParenthesis(this, parenthesis, options && options.implicit)) {\n          expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n        }\n\n        return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right):=' + expr;\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new FunctionAssignmentNode(json.name, json.params, json.expr);\n      }\n    }]);\n\n    return FunctionAssignmentNode;\n  }(Node);\n\n  _defineProperty(FunctionAssignmentNode, \"name\", name);\n\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isNode","keywords","escape","forEach","join","toSymbol","getPrecedence","factory","name","dependencies","createFunctionAssignmentNode","_ref","typed","Node","needParenthesis","node","parenthesis","implicit","precedence","exprPrecedence","expr","FunctionAssignmentNode","params","TypeError","Array","isArray","has","Error","map","param","types","type","math","argNames","childArgNames","Object","create","evalExpr","_compile","signature","syntax","evalFunctionAssignmentNode","scope","args","context","signatures","childArgs","i","length","arguments","fn","set","callback","_ifNode","slice","options","toString","mathjs","index","push","toHTML","toTex","concat","json","isClass"],"sources":["/workspaces/Calculator-React/node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { escape } from '../../utils/string.js';\nimport { forEach, join } from '../../utils/array.js';\nimport { toSymbol } from '../../utils/latex.js';\nimport { getPrecedence } from '../operators.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    Node\n  } = _ref;\n\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @param {string} implicit\n   * @private\n   */\n  function needParenthesis(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n\n  class FunctionAssignmentNode extends Node {\n    /**\n     * @constructor FunctionAssignmentNode\n     * @extends {Node}\n     * Function assignment\n     *\n     * @param {string} name           Function name\n     * @param {string[] | Array.<{name: string, type: string}>} params\n     *                                Array with function parameter names, or an\n     *                                array with objects containing the name\n     *                                and type of the parameter\n     * @param {Node} expr             The function expression\n     */\n    constructor(name, params, expr) {\n      super(); // validate input\n\n      if (typeof name !== 'string') {\n        throw new TypeError('String expected for parameter \"name\"');\n      }\n\n      if (!Array.isArray(params)) {\n        throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n      }\n\n      if (!isNode(expr)) {\n        throw new TypeError('Node expected for parameter \"expr\"');\n      }\n\n      if (keywords.has(name)) {\n        throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n      }\n\n      this.name = name;\n      this.params = params.map(function (param) {\n        return param && param.name || param;\n      });\n      this.types = params.map(function (param) {\n        return param && param.type || 'any';\n      });\n      this.expr = expr;\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isFunctionAssignmentNode() {\n      return true;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      var childArgNames = Object.create(argNames);\n      forEach(this.params, function (param) {\n        childArgNames[param] = true;\n      }); // compile the function expression with the child args\n\n      var evalExpr = this.expr._compile(math, childArgNames);\n\n      var name = this.name;\n      var params = this.params;\n      var signature = join(this.types, ',');\n      var syntax = name + '(' + join(this.params, ', ') + ')';\n      return function evalFunctionAssignmentNode(scope, args, context) {\n        var signatures = {};\n\n        signatures[signature] = function () {\n          var childArgs = Object.create(args);\n\n          for (var i = 0; i < params.length; i++) {\n            childArgs[params[i]] = arguments[i];\n          }\n\n          return evalExpr(scope, childArgs, context);\n        };\n\n        var fn = typed(name, signatures);\n        fn.syntax = syntax;\n        scope.set(name, fn);\n        return fn;\n      };\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      callback(this.expr, 'expr', this);\n    }\n    /**\n     * Create a new FunctionAssignmentNode whose children are the results of\n     * calling the provided callback function for each child of the original\n     * node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      var expr = this._ifNode(callback(this.expr, 'expr', this));\n\n      return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {FunctionAssignmentNode}\n     */\n\n\n    clone() {\n      return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n    }\n    /**\n     * get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var expr = this.expr.toString(options);\n\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\n        expr = '(' + expr + ')';\n      }\n\n      return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      var types = this.types;\n      return {\n        mathjs: name,\n        name: this.name,\n        params: this.params.map(function (param, index) {\n          return {\n            name: param,\n            type: types[index]\n          };\n        }),\n        expr: this.expr\n      };\n    }\n    /**\n     * Instantiate an FunctionAssignmentNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     ```\n     *     {\"mathjs\": \"FunctionAssignmentNode\",\n     *      name: ..., params: ..., expr: ...}\n     *     ```\n     *     where mathjs is optional\n     * @returns {FunctionAssignmentNode}\n     */\n\n\n    static fromJSON(json) {\n      return new FunctionAssignmentNode(json.name, json.params, json.expr);\n    }\n    /**\n     * get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var params = [];\n\n      for (var i = 0; i < this.params.length; i++) {\n        params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n      }\n\n      var expr = this.expr.toHTML(options);\n\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\n        expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n    }\n    /**\n     * get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var expr = this.expr.toTex(options);\n\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\n        expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n      }\n\n      return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right):=' + expr;\n    }\n\n  }\n\n  _defineProperty(FunctionAssignmentNode, \"name\", name);\n\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":";;;;AAAA,OAAOA,eAAP,MAA4B,uCAA5B;AACA,SAASC,MAAT,QAAuB,mBAAvB;AACA,SAASC,QAAT,QAAyB,gBAAzB;AACA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,OAAT,EAAkBC,IAAlB,QAA8B,sBAA9B;AACA,SAASC,QAAT,QAAyB,sBAAzB;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,IAAIC,IAAI,GAAG,wBAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,MAAV,CAAnB;AACA,OAAO,IAAIC,4BAA4B,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAqB,UAAAE,IAAI,EAAI;EAC3F,IACEC,KADF,GAGID,IAHJ,CACEC,KADF;EAAA,IAEEC,IAFF,GAGIF,IAHJ,CAEEE,IAFF;EAKA;AACF;AACA;AACA;AACA;AACA;AACA;;EACE,SAASC,eAAT,CAAyBC,IAAzB,EAA+BC,WAA/B,EAA4CC,QAA5C,EAAsD;IACpD,IAAIC,UAAU,GAAGZ,aAAa,CAACS,IAAD,EAAOC,WAAP,EAAoBC,QAApB,CAA9B;IACA,IAAIE,cAAc,GAAGb,aAAa,CAACS,IAAI,CAACK,IAAN,EAAYJ,WAAZ,EAAyBC,QAAzB,CAAlC;IACA,OAAOD,WAAW,KAAK,KAAhB,IAAyBG,cAAc,KAAK,IAAnB,IAA2BA,cAAc,IAAID,UAA7E;EACD;;EAjB0F,IAmBrFG,sBAnBqF;IAAA;;IAAA;;IAoBzF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,gCAAYb,IAAZ,EAAkBc,MAAlB,EAA0BF,IAA1B,EAAgC;MAAA;;MAAA;;MAC9B,0BAD8B,CACrB;;MAET,IAAI,OAAOZ,IAAP,KAAgB,QAApB,EAA8B;QAC5B,MAAM,IAAIe,SAAJ,CAAc,sCAAd,CAAN;MACD;;MAED,IAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,MAAd,CAAL,EAA4B;QAC1B,MAAM,IAAIC,SAAJ,CAAc,qEAAd,CAAN;MACD;;MAED,IAAI,CAACvB,MAAM,CAACoB,IAAD,CAAX,EAAmB;QACjB,MAAM,IAAIG,SAAJ,CAAc,oCAAd,CAAN;MACD;;MAED,IAAItB,QAAQ,CAACyB,GAAT,CAAalB,IAAb,CAAJ,EAAwB;QACtB,MAAM,IAAImB,KAAJ,CAAU,6BAA6BnB,IAA7B,GAAoC,yBAA9C,CAAN;MACD;;MAED,MAAKA,IAAL,GAAYA,IAAZ;MACA,MAAKc,MAAL,GAAcA,MAAM,CAACM,GAAP,CAAW,UAAUC,KAAV,EAAiB;QACxC,OAAOA,KAAK,IAAIA,KAAK,CAACrB,IAAf,IAAuBqB,KAA9B;MACD,CAFa,CAAd;MAGA,MAAKC,KAAL,GAAaR,MAAM,CAACM,GAAP,CAAW,UAAUC,KAAV,EAAiB;QACvC,OAAOA,KAAK,IAAIA,KAAK,CAACE,IAAf,IAAuB,KAA9B;MACD,CAFY,CAAb;MAGA,MAAKX,IAAL,GAAYA,IAAZ;MA1B8B;IA2B/B;;IA3DwF;MAAA;MAAA,KA6DzF,eAAW;QACT,OAAOZ,IAAP;MACD;IA/DwF;MAAA;MAAA,KAiEzF,eAA+B;QAC7B,OAAO,IAAP;MACD;MACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAhF6F;MAAA;MAAA,OAmFzF,kBAASwB,IAAT,EAAeC,QAAf,EAAyB;QACvB,IAAIC,aAAa,GAAGC,MAAM,CAACC,MAAP,CAAcH,QAAd,CAApB;QACA9B,OAAO,CAAC,KAAKmB,MAAN,EAAc,UAAUO,KAAV,EAAiB;UACpCK,aAAa,CAACL,KAAD,CAAb,GAAuB,IAAvB;QACD,CAFM,CAAP,CAFuB,CAInB;;QAEJ,IAAIQ,QAAQ,GAAG,KAAKjB,IAAL,CAAUkB,QAAV,CAAmBN,IAAnB,EAAyBE,aAAzB,CAAf;;QAEA,IAAI1B,IAAI,GAAG,KAAKA,IAAhB;QACA,IAAIc,MAAM,GAAG,KAAKA,MAAlB;QACA,IAAIiB,SAAS,GAAGnC,IAAI,CAAC,KAAK0B,KAAN,EAAa,GAAb,CAApB;QACA,IAAIU,MAAM,GAAGhC,IAAI,GAAG,GAAP,GAAaJ,IAAI,CAAC,KAAKkB,MAAN,EAAc,IAAd,CAAjB,GAAuC,GAApD;QACA,OAAO,SAASmB,0BAAT,CAAoCC,KAApC,EAA2CC,IAA3C,EAAiDC,OAAjD,EAA0D;UAC/D,IAAIC,UAAU,GAAG,EAAjB;;UAEAA,UAAU,CAACN,SAAD,CAAV,GAAwB,YAAY;YAClC,IAAIO,SAAS,GAAGX,MAAM,CAACC,MAAP,CAAcO,IAAd,CAAhB;;YAEA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzB,MAAM,CAAC0B,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;cACtCD,SAAS,CAACxB,MAAM,CAACyB,CAAD,CAAP,CAAT,GAAuBE,SAAS,CAACF,CAAD,CAAhC;YACD;;YAED,OAAOV,QAAQ,CAACK,KAAD,EAAQI,SAAR,EAAmBF,OAAnB,CAAf;UACD,CARD;;UAUA,IAAIM,EAAE,GAAGtC,KAAK,CAACJ,IAAD,EAAOqC,UAAP,CAAd;UACAK,EAAE,CAACV,MAAH,GAAYA,MAAZ;UACAE,KAAK,CAACS,GAAN,CAAU3C,IAAV,EAAgB0C,EAAhB;UACA,OAAOA,EAAP;QACD,CAjBD;MAkBD;MACD;AACJ;AACA;AACA;;IArH6F;MAAA;MAAA,OAwHzF,iBAAQE,QAAR,EAAkB;QAChBA,QAAQ,CAAC,KAAKhC,IAAN,EAAY,MAAZ,EAAoB,IAApB,CAAR;MACD;MACD;AACJ;AACA;AACA;AACA;AACA;AACA;;IAjI6F;MAAA;MAAA,OAoIzF,aAAIgC,QAAJ,EAAc;QACZ,IAAIhC,IAAI,GAAG,KAAKiC,OAAL,CAAaD,QAAQ,CAAC,KAAKhC,IAAN,EAAY,MAAZ,EAAoB,IAApB,CAArB,CAAX;;QAEA,OAAO,IAAIC,sBAAJ,CAA2B,KAAKb,IAAhC,EAAsC,KAAKc,MAAL,CAAYgC,KAAZ,CAAkB,CAAlB,CAAtC,EAA4DlC,IAA5D,CAAP;MACD;MACD;AACJ;AACA;AACA;;IA5I6F;MAAA;MAAA,OA+IzF,iBAAQ;QACN,OAAO,IAAIC,sBAAJ,CAA2B,KAAKb,IAAhC,EAAsC,KAAKc,MAAL,CAAYgC,KAAZ,CAAkB,CAAlB,CAAtC,EAA4D,KAAKlC,IAAjE,CAAP;MACD;MACD;AACJ;AACA;AACA;AACA;;IAtJ6F;MAAA;MAAA,OAyJzF,mBAAUmC,OAAV,EAAmB;QACjB,IAAIvC,WAAW,GAAGuC,OAAO,IAAIA,OAAO,CAACvC,WAAnB,GAAiCuC,OAAO,CAACvC,WAAzC,GAAuD,MAAzE;QACA,IAAII,IAAI,GAAG,KAAKA,IAAL,CAAUoC,QAAV,CAAmBD,OAAnB,CAAX;;QAEA,IAAIzC,eAAe,CAAC,IAAD,EAAOE,WAAP,EAAoBuC,OAAO,IAAIA,OAAO,CAACtC,QAAvC,CAAnB,EAAqE;UACnEG,IAAI,GAAG,MAAMA,IAAN,GAAa,GAApB;QACD;;QAED,OAAO,KAAKZ,IAAL,GAAY,GAAZ,GAAkB,KAAKc,MAAL,CAAYlB,IAAZ,CAAiB,IAAjB,CAAlB,GAA2C,MAA3C,GAAoDgB,IAA3D;MACD;MACD;AACJ;AACA;AACA;;IAtK6F;MAAA;MAAA,OAyKzF,kBAAS;QACP,IAAIU,KAAK,GAAG,KAAKA,KAAjB;QACA,OAAO;UACL2B,MAAM,EAAEjD,IADH;UAELA,IAAI,EAAE,KAAKA,IAFN;UAGLc,MAAM,EAAE,KAAKA,MAAL,CAAYM,GAAZ,CAAgB,UAAUC,KAAV,EAAiB6B,KAAjB,EAAwB;YAC9C,OAAO;cACLlD,IAAI,EAAEqB,KADD;cAELE,IAAI,EAAED,KAAK,CAAC4B,KAAD;YAFN,CAAP;UAID,CALO,CAHH;UASLtC,IAAI,EAAE,KAAKA;QATN,CAAP;MAWD;MACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAjM6F;MAAA;MAAA;MAuMzF;AACJ;AACA;AACA;AACA;MAGI,gBAAOmC,OAAP,EAAgB;QACd,IAAIvC,WAAW,GAAGuC,OAAO,IAAIA,OAAO,CAACvC,WAAnB,GAAiCuC,OAAO,CAACvC,WAAzC,GAAuD,MAAzE;QACA,IAAIM,MAAM,GAAG,EAAb;;QAEA,KAAK,IAAIyB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKzB,MAAL,CAAY0B,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;UAC3CzB,MAAM,CAACqC,IAAP,CAAY,8CAA8CzD,MAAM,CAAC,KAAKoB,MAAL,CAAYyB,CAAZ,CAAD,CAApD,GAAuE,SAAnF;QACD;;QAED,IAAI3B,IAAI,GAAG,KAAKA,IAAL,CAAUwC,MAAV,CAAiBL,OAAjB,CAAX;;QAEA,IAAIzC,eAAe,CAAC,IAAD,EAAOE,WAAP,EAAoBuC,OAAO,IAAIA,OAAO,CAACtC,QAAvC,CAAnB,EAAqE;UACnEG,IAAI,GAAG,mEAAmEA,IAAnE,GAA0E,gEAAjF;QACD;;QAED,OAAO,iCAAiClB,MAAM,CAAC,KAAKM,IAAN,CAAvC,GAAqD,SAArD,GAAiE,gEAAjE,GAAoIc,MAAM,CAAClB,IAAP,CAAY,uCAAZ,CAApI,GAA2L,gEAA3L,GAA8P,sDAA9P,GAAuT,kEAAvT,GAA4XgB,IAAnY;MACD;MACD;AACJ;AACA;AACA;AACA;;IAlO6F;MAAA;MAAA,OAqOzF,gBAAOmC,OAAP,EAAgB;QACd,IAAIvC,WAAW,GAAGuC,OAAO,IAAIA,OAAO,CAACvC,WAAnB,GAAiCuC,OAAO,CAACvC,WAAzC,GAAuD,MAAzE;QACA,IAAII,IAAI,GAAG,KAAKA,IAAL,CAAUyC,KAAV,CAAgBN,OAAhB,CAAX;;QAEA,IAAIzC,eAAe,CAAC,IAAD,EAAOE,WAAP,EAAoBuC,OAAO,IAAIA,OAAO,CAACtC,QAAvC,CAAnB,EAAqE;UACnEG,IAAI,GAAG,UAAU0C,MAAV,CAAiB1C,IAAjB,EAAuB,UAAvB,CAAP;QACD;;QAED,OAAO,cAAc,KAAKZ,IAAnB,GAA0B,UAA1B,GAAuC,KAAKc,MAAL,CAAYM,GAAZ,CAAgBvB,QAAhB,EAA0BD,IAA1B,CAA+B,GAA/B,CAAvC,GAA6E,YAA7E,GAA4FgB,IAAnG;MACD;IA9OwF;MAAA;MAAA,OAoMzF,kBAAgB2C,IAAhB,EAAsB;QACpB,OAAO,IAAI1C,sBAAJ,CAA2B0C,IAAI,CAACvD,IAAhC,EAAsCuD,IAAI,CAACzC,MAA3C,EAAmDyC,IAAI,CAAC3C,IAAxD,CAAP;MACD;IAtMwF;;IAAA;EAAA,EAmBtDP,IAnBsD;;EAkP3Fd,eAAe,CAACsB,sBAAD,EAAyB,MAAzB,EAAiCb,IAAjC,CAAf;;EAEA,OAAOa,sBAAP;AACD,CArP+D,EAqP7D;EACD2C,OAAO,EAAE,IADR;EAEDhE,MAAM,EAAE;AAFP,CArP6D,CAAzD"},"metadata":{},"sourceType":"module"}